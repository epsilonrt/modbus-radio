<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Modbus-Radio: Modbus Radio Library for Arduino</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="modbus.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Modbus-Radio
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Modbus Radio Library for Arduino </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a>Over-the-air implementation for RadioHead compatible modules.</p>
<p><a href="https://github.com/epsilonrt/modbus-radio/releases"><img src="https://img.shields.io/github/v/release/epsilonrt/modbus-radio?include_prereleases" alt="GitHub release (latest by date including pre-releases)" class="inline"/></a> <a href="https://registry.platformio.org/libraries/epsilonrt/modbus-radio"><img src="https://badges.registry.platformio.org/packages/epsilonrt/library/modbus-radio.svg" alt="PlatformIO Registry" style="pointer-events: none;" class="inline"/></a> <a href="https://www.arduinolibraries.info/libraries/modbus-radio"><img src="https://www.ardu-badge.com/badge/Modbus-Radio.svg" alt="Arduino Registry" style="pointer-events: none;" class="inline"/></a></p>
<p><a href="https://www.arduino.cc/"><img src="https://img.shields.io/badge/Framework-Arduino-blue" alt="Framework" class="inline"/></a> <a href="https://github.com/epsilonrt/modbus-radio/actions/workflows/build_mega.yml"><img src="https://github.com/epsilonrt/modbus-radio/actions/workflows/build_mega.yml/badge.svg" alt="Mega" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/epsilonrt/modbus-radio/actions/workflows/build_vidor.yml"><img src="https://github.com/epsilonrt/modbus-radio/actions/workflows/build_vidor.yml/badge.svg" alt="Vidor" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/epsilonrt/modbus-radio/actions/workflows/build_teensy.yml"><img src="https://github.com/epsilonrt/modbus-radio/actions/workflows/build_teensy.yml/badge.svg" alt="Teensy" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/epsilonrt/modbus-radio/actions/workflows/build_esp32.yml"><img src="https://github.com/epsilonrt/modbus-radio/actions/workflows/build_esp32.yml/badge.svg" alt="Esp32" style="pointer-events: none;" class="inline"/></a></p>
<hr  />
<p>This library allows your Arduino to communicate via Modbus protocol. The Modbus is a master-slave protocol used in industrial automation and can be used in other areas, such as home automation.</p>
<p>The Modbus generally uses serial RS-232 or RS-485 as physical layer (then called Modbus Serial) and TCP/IP via Ethernet or WiFi (Modbus TCP). But it is also possible to associate the Modbus application protocol on any other physical layer, such as the radio.</p>
<p><img src="https://github.com/epsilonrt/modbus-arduino/raw/master/extras/modbus-stack.png" alt="Modbus Stack" class="inline"/></p>
<p>In the current version the library allows the Arduino operate <b>as a slave</b>, supporting Modbus over-the-air for hardware modules supported by the <a href="https://github.com/epsilonrt/RadioHead/tree/mikem">RadioHead</a> library.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
How to</h1>
<p>There are five classes corresponding to six headers that may be used:</p>
<ul>
<li><a href="http://github.com/epsilonrt/modbus-arduino">Modbus-Arduino</a> - Base Library <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-serial">Modbus-Serial</a> - Modbus Serial RTU Library <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-ethernet">Modbus-Ethernet</a> - Modbus TCP Library (standard Ethernet Shield) <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-ethercard">Modbus-EtherCard</a> - Modbus TCP Library (for ENC28J60 chip) <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-esp8266at">Modbus-Esp8266AT</a> - Modbus IP Library (for ESP8266 chip with AT firmware) <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-radio">Modbus-Radio</a> - Modbus Radio Library for RadioHead compatible chips (<b>this repository</b>) <br  />
</li>
</ul>
<p>By opting for Modbus Serial, TCP or Radio you must include in your sketch the corresponding header : </p><pre class="fragment">#include &lt;ModbusRadio.h&gt;
</pre> <h1><a class="anchor" id="autotoc_md3"></a>
Modbus-Radio</h1>
<p>The Modbus-Radio library allows the Arduino to communicate via Modbus protocol using the <a href="https://github.com/epsilonrt/RadioHead/tree/mikem">RadioHead</a> library for radio communication. This physical layer is not defined in the Modbus standard, but it is possible to use the Modbus application protocol over any physical layer. For do this, the Modbus-Radio library implements the physical layer using the <a href="http://www.airspayce.com/mikem/arduino/RadioHead/classRHGenericDriver.html">RHGenericDriver</a> class. <br  />
 This allows the use of any hardware module whose class is derived from this class, but also the use of encryption with the <a href="http://www.airspayce.com/mikem/arduino/RadioHead/classRHEncryptedDriver.html">RHEncryptedDriver</a> class and the <a href="http://rweather.github.io/arduinolibs/index.html">Crypto</a> library. <br  />
 Mention may be made, for example, of the very famous <a href="http://www.airspayce.com/mikem/arduino/RadioHead/classRHSPIDriver.html">SPI</a> RFM22, RFM24, RFM69 and RFM95 modules.</p>
<p>The MODBUS protocol defines a simple protocol data unit (<b>PDU</b>) independent of the underlying communication layers. The mapping of MODBUS protocol on specific buses or network can introduce some additional fields on the application data unit (<b>ADU</b>)</p>
<p><img src="https://github.com/epsilonrt/modbus-radio/raw/main/extras/images/adu-pdu.png" alt="Modbus ADU" class="inline"/></p>
<p>Modbus-Radio uses the <b>same ADU as for Mobdus RTU</b> OSL (Over Serial Line)</p>
<p><img src="https://github.com/epsilonrt/modbus-radio/raw/main/extras/images/adu-rtu.png" alt="Modbus ADU" class="inline"/></p>
<p>the Address field only contains the slave address. The individual slave devices are assigned addresses in the range of 1 – 247. <br  />
 The Address 0 is reserved as the broadcast address. All slave nodes must recognise the broadcast address. <br  />
 A master addresses a slave by placing the slave address in the address field of the message. When the slave returns its response, it places its own address in the response address field to let the master know which slave is responding. <br  />
 The ADU includes an error–checking field that is based on a Cyclical Redundancy Checking (CRC) method performed on the message contents. <br  />
 The CRC field checks the contents of the entire message. The CRC field contains a 16–bit value implemented as two 8–bit bytes.</p>
<p>Thus it is not necessary to use the classes derived from RHDatagram because this protocol provides addressing, integrity control and acknowledgment.</p>
<p>There are six <a href="https://github.com/epsilonrt/modbus-radio/tree/master/examples">examples</a> that can be accessed from the Arduino interface, once you have installed the library.</p>
<ul>
<li><a href="https://github.com/epsilonrt/modbus-radio/blob/master/examples/Lamp/Lamp.ino">Lamp</a>: Use a coil to turn on and off a LED (0x05 and 0x01 functions) <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-radio/blob/master/examples/LampEncrypted/LampEncrypted.ino">LampEncrypted</a>: Use a coil to turn on and off a LED (0x05 and 0x01 functions) with encrypted communication. <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-radio/blob/master/examples/LampDimmer/LampDimmer.ino">LampDimmer</a>: Use a holding register to control the brightness of a LED (0x06 and 0x03 functions) <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-radio/blob/master/examples/Switch/Switch.ino">Switch</a>: Use a discrete input to read the state of a switch (0x02 function) <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-radio/blob/master/examples/TempSensor/TempSensor.ino">TempSensor</a>: Use a input register to read the temperature from a sensor (0x04 function) <br  />
</li>
<li><a href="https://github.com/epsilonrt/modbus-radio/blob/master/examples/Servo/Servo.ino">Servo</a>: Use a holding register to control the position of a servo motor (0x06 an 0x03 function). Show how to define boundaries for the register. <br  />
</li>
</ul>
<p>Let's look at the example Lamp.ino (only the parts concerning Modbus and RadioHead will be commented): </p><pre class="fragment">#include &lt;ModbusRadio.h&gt;
</pre><p> Inclusion of the necessary library. </p><pre class="fragment">const byte SlaveId = 10;
</pre><p> Sets the slave address. This value is the address of the slave device. The address range is 1 to 247. </p><pre class="fragment">const int Lamp1Coil = 0;
</pre><p> Sets the Modbus register to represent the switch. This value is the offset (0-based) to be placed in its supervisory or testing software. Note that if your software uses offsets 1-based the set value there should be 101, for this example. </p><pre class="fragment">const float frequency = 868.0;
</pre><p> Sets the frequency of the radio module. This value is in MHz and can be 315, 433, 868 or 915. </p><pre class="fragment">RH_RF95 radio;
</pre><p> Create the radio instance (RH_RF95) to be used. The syntax is equal to RadioHead class, and supports the formats described in the <a href="http://www.airspayce.com/mikem/arduino/RadioHead/classRH__RF95.html#a274c170acdb53f55fd45445ab7f51889">documentation</a>. </p><pre class="fragment">ModbusRadio mb (SlaveId);
</pre><p> Create the mb instance (<a class="el" href="class_modbus_radio.html" title="Modbus over-the-air for devices supported by the RadioHead library.">ModbusRadio</a>) to be used with the slave address. </p><pre class="fragment">if (!radio.init()) {
  Console.println ("radio init failed !");
  Console.flush();
  exit (EXIT_FAILURE);
}
</pre><p> Initializes the radio module. If the initialization fails, the program is terminated. The default configuration is used : Bw = 125 kHz, Cr = 5 (4/5), Sf = 7 (128chips/symbol), CRC on. The transmitter power is 13dBm.</p>
<p>If necessary, you can change the configuration by calling the following methods: </p><pre class="fragment">radio.setModemConfig(RH_RF95::Bw500Cr45Sf128);
</pre><p> Sets the modem configuration. </p><pre class="fragment">radio.setFrequency (frequency);
</pre><p> Sets the frequency of the radio module. This value is in MHz and can be 315, 433, 868 or 915. </p><pre class="fragment">radio.setTxPower (20);
</pre><p> Sets the transmitter power in dBm. The default is 13dBm and can be set between +5 and +23 dBm. </p><pre class="fragment">mb.config (radio);
</pre><p> Initializes the <a class="el" href="class_modbus_radio.html" title="Modbus over-the-air for devices supported by the RadioHead library.">ModbusRadio</a> instance by passing the radio instance as parameter. </p><pre class="fragment">mb.setAdditionalServerData ("LAMP");
</pre><p> Set the additional server data. This data will be sent in the response to the Report Server ID function (0x11). </p><pre class="fragment">mb.setDebug (Console);
</pre><p> Sets the debug output. The debug output is used to display the Modbus frames and other information. The debug output can be any class that implements the Print interface, such as Serial or Console.</p>
<p>Then we have: </p><pre class="fragment">mb.addCoil (Lamp1Coil);
</pre><p> Adds the register type Coil (digital output) that will be responsible for activating the LED or lamp and verify their status.</p>
<p>The library allows you to set an initial value for the register: </p><pre class="fragment">mb.addCoil (Lamp1Coil, true);
</pre><p> In this case the register is added and set to true. If you use the first form the default value is false. </p><pre class="fragment">mb.task ();
</pre><p> This method makes all magic, answering requests and changing the registers if necessary, it should be called only once, early in the loop. </p><pre class="fragment">digitalWrite (LedPin, mb.coil (Lamp1Coil));
</pre><p> Finally the value of Lamp1Coil register is used to drive the lamp or LED.</p>
<p>In much the same way, the other examples show the use of other methods available in the library: </p><pre class="fragment">void addCoil (offset word, bool value)
void addHreg (offset word, word value)
void addIsts (offset word, bool value)
void addIreg (offset word, word value)
</pre><p> Adds registers and configures initial value if specified. </p><pre class="fragment">bool setCoil (offset word, bool value)
bool setHreg (offset word, word value)
bool setIsts (offset word, bool value)
bool setIReg (offset word, word value)
</pre><p> Sets a value to the register. </p><pre class="fragment">bool coil (offset word)
word hreg  (word offset)
bool ists (offset word)
word ireg (word offset)
</pre><p> Returns the value of a register.</p>
<p><b>Notes:</b></p>
<ol type="1">
<li>The RadioHead library is not included in the Modbus-Radio library, you must install it separately if you are not using <a href="https://platformio.org/">Platformio</a> or <a href="https://arduino.github.io/arduino-cli">Arduino Cli</a>. This library is published in the <a href="https://www.arduinolibraries.info/libraries/modbus-radio">Arduino Library Manager</a>, so you can install it directly from the Arduino interface. It is important to know that RadioHead is published according to 2 licenses: the GNU Public License and a commercial license if you do not wish to distribute the sources of your software. <br  />
</li>
<li>If you want to use encryption, you must install the <a href="http://rweather.github.io/arduinolibs/index.html">Crypto</a> library and define RH_ENABLE_ENCRYPTION_MODULE, by uncomment #define RH_ENABLE_ENCRYPTION_MODULE at the bottom of RadioHead.h, or using a -D option passed to the compiler.</li>
</ol>
<h1><a class="anchor" id="autotoc_md4"></a>
License</h1>
<p>The code in this repo is licensed under the BSD New License. See LICENSE for more info. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
